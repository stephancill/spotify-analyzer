<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hello</title>
    </head>
    <body>
        <h1>Songs</h1><span>(</span><span id="totalLookedUp">0</span><span>/</span><span id="totalSongs"></span><span>)</span>
        <span>(ETA: </span><span id="eta"></span><span> seconds)</span>
        <br>
        <span>Current: </span><span id="current"></span>
        <div id="songs" class="">

        </div>
    </body>
</html>
<script type="text/javascript">

var spotify_client_id = '04ec33bc2f0544b4b06c9c78c251ff07'; // Your client id (meh)
var spotify_client_secret = '595fe83b487d4924baef110f240d129b'; // Your secret (meh)
// var redirect_uri = 'http://localhost:8008/callback'; // Your redirect uri
var redirect_uri = (location.origin == "http://localhost:8008" ? location.origin+'/callback' : location.origin.location.pathname + "/callback")
var auth_url = `https://accounts.spotify.com/authorize/?client_id=${spotify_client_id}&response_type=code&redirect_uri=${encodeURIComponent(redirect_uri)}&scope=user-library-read`

var access_token = null
var refresh_token = null

var lastfm_api_key = "b25b959554ed76058ac220b7b2e0a026"

var songs = []
var requestedSongs = []
var lastFMProcessIndex = 0
var timer = null

var genreDemographics = {}

var totalTime = 0

if (location.pathname === "/callback") {
    authenticate(spotify_client_id, spotify_client_secret, redirect_uri, populateSongs)
} else {
    location.replace(auth_url)
}

function recursiveGet(responseData, endpoint, request, requestsMade, limit, maxRequests=null, callback=()=>{}) {
    if (maxRequests !== null) {
        if (requestsMade > maxRequests) {
            callback()
            return
        }
    }
    if (!(responseData.items.length < limit)) {
        fetch(endpoint + `?limit=${limit}&offset=${requestsMade * limit}`, request)
        .then((blob) => blob.json())
        .then((data) => {
            songs.push(...data.items)
            createSongElements(data.items)
            recursiveGet(data, endpoint, request, requestsMade+1, limit, maxRequests, callback)
        })
    } else {
        callback()
    }
}

function populateSongs(access_token) {
    totalTime = new Date()

    var endpoint = "https://api.spotify.com/v1/me/tracks"

    var headers = new Headers()
    headers.append('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8')
    headers.append('Authorization', "Bearer " + access_token)

    var request = { method: 'GET',
                   headers: headers,
                   mode: 'cors',
                   cache: 'default' }

    var requestsMade = 0
    var limit = 50

    fetch(endpoint + `?limit=${limit}&offset=${requestsMade * limit}`, request)
    .then((blob) => blob.json())
    .then((data) => {
        data.items.map(item => {
            songs.push({title: item.track.name, artist: item.track.artists[0].name})
        })
        getTagsForSongs()
        createSongElements(data.items)
        recursiveGet(data, endpoint, request, requestsMade+1, limit, 0)
    })
}

function getTagsForSongs() {
    console.warn("Getting tags");
    timer = setInterval(getSongTags, 200) // Last.fm limits requests to 5 per second per IP
}

function getSongTags() {

    if (lastFMProcessIndex < songs.length) {
        var title = songs[lastFMProcessIndex].title
        var artist = songs[lastFMProcessIndex].artist
// method=track.getInfo&api_key=b25b959554ed76058ac220b7b2e0a026&artist=cher&track=believe&format=json
        var endpoint = `http://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${lastfm_api_key}`
        var params = `&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(title)}`
        var appendix = "&user=RJ&format=json"
        // console.log(title, artist);
        lastFMProcessIndex += 1
        var cookie = getCookie(title+artist)
        if (cookie != "") {
            var tags = JSON.parse(cookie)
            var index = lastFMProcessIndex - 1
            console.warn("found cookie");
            tags.map(tag => {
                item = tag.name
                if (lastFMProcessIndex < songs.length) {
                    if (genreDemographics[item]) {
                        genreDemographics[item]["count"] += 1
                        genreDemographics[item]["tracks"].push(songs[index])
                    } else {
                        genreDemographics[item] = {}
                        genreDemographics[item]["count"] = 1
                        genreDemographics[item]["tracks"] = [songs[index]]
                    }
                }
            })
            requestedSongs.push({title: title, artist: artist, tags: tags})
            document.getElementById("totalLookedUp").innerHTML = lastFMProcessIndex
            document.getElementById("eta").innerHTML = 200 * (songs.length - lastFMProcessIndex) / 1000
            // console.log(JSON.parse(cookie).split(",").splice(0, JSON.parse(cookie).split(",").length-2));
            tags = ((tags.length === 0) ? "" : tags.reduce((acc, tag) => {
                return (acc + "" === "[object Object]" ? "" : acc) + tag.name + ","
            }))
            document.getElementById("current").innerHTML = title + " - " + artist + "[" + tags + "]"
        } else {
            console.log("network");
            fetch(endpoint + params + appendix)
            .then(blob => blob.json())
            .then(data => {
                var index = lastFMProcessIndex - 1
                tags =  data.track.toptags.tag
                tags.map(tag => {
                    item = tag.name
                    if (lastFMProcessIndex < songs.length) {
                        if (genreDemographics[item]) {
                            genreDemographics[item]["count"] += 1
                            genreDemographics[item]["tracks"].push(songs[index])
                        } else {
                            genreDemographics[item] = {}
                            genreDemographics[item]["count"] = 1
                            genreDemographics[item]["tracks"] = [songs[index]]
                        }
                    }
                })
                setCookie(title+artist, JSON.stringify(tags), 365)
                console.warn("set cookie", JSON.stringify(tags));
                requestedSongs.push({title: title, artist: artist, tags: tags})
                document.getElementById("totalLookedUp").innerHTML = lastFMProcessIndex
                document.getElementById("eta").innerHTML = 200 * (songs.length - lastFMProcessIndex) / 1000
                var tags = ((tags.length === 0) ? "" : tags.reduce((acc, tag) => {
                    return (acc + "" === "[object Object]" ? "" : acc) + tag.name + ","
                }))
                document.getElementById("current").innerHTML = title + " - " + artist + "[" + tags + "]"
            })
        }


    } else {
        console.log("clearing");
        window.clearInterval(timer)
        analyzeSongs()
    }

}

function analyzeSongs() {
    console.log("Analyzing");
    // console.log(genreDemographics);
    var keysSorted = Object.keys(genreDemographics).sort(function(b,a){return genreDemographics[a].count-genreDemographics[b].count})
    var tabulated = []
    for (var i = 0; i < keysSorted.length; i++) {
        console.log(genreDemographics[keysSorted[i]].tracks);
        tabulated.push([keysSorted[i], genreDemographics[keysSorted[i]].count, genreDemographics[keysSorted[i]].tracks])
    }
    console.table(tabulated)
    console.warn(new Date() - totalTime);
}

function createSongElements(tracks) {
    // var container = document.getElementById("songs")
    // var html = ""
    // tracks.map(track => {
    //     html += `<span>${track.track.name} - ${track.track.artists[0].name}</span><br>`
    // })
    // container.innerHTML += html
    document.getElementById("totalSongs").innerHTML = songs.length
}

function authenticate(spotify_client_id, spotify_client_secret, redirect_uri, callback) {
    var access_token = null
    var refresh_token = null

    function b64EncodeUnicode(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
            return String.fromCharCode('0x' + p1)
        }));
    }

    function httpGetAsync(theUrl, params, callback)
    {
        var xmlHttp = new XMLHttpRequest()
        xmlHttp.onreadystatechange = function() {
            if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
                callback(xmlHttp.responseText, xmlHttp.status)
            }
        }
        xmlHttp.open("POST", theUrl, true); // true for asynchronous
        xmlHttp.setRequestHeader("Authorization", "Basic " + b64EncodeUnicode(`${spotify_client_id}:${spotify_client_secret}`))
        xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=UTF-8")
        xmlHttp.send(params)
    }

    function gup(name, url) {
        if (!url) url = location.href;
        name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]")
        var regexS = "[\\?&]"+name+"=([^&#]*)"
        var regex = new RegExp( regexS )
        var results = regex.exec( url )
        return results == null ? null : results[1]
    }

    if (!(gup("error"))) {
        // console.log(gup("code"));
        httpGetAsync("https://accounts.spotify.com/api/token", `grant_type=authorization_code&code=${gup("code")}&redirect_uri=${encodeURIComponent(redirect_uri)}`, (responseText) => {
            var json = JSON.parse(responseText)
            access_token = json.access_token
            refresh_token = json.refresh_token
            callback(access_token, refresh_token)
        })
    } else {
        console.error("Error");
    }
}

// COOKIES
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires="+d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
}

function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

</script>

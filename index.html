<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hello</title>
    </head>
    <body>
        <h1>Spotify Library Analyzer</h1>
        <h2 id="fetchStatus">Fetching/parsing songs...</h2>
        <span>(</span><span id="totalLookedUp">0</span><span>/</span><span id="totalSongs">?</span><span>)</span>
        <span>(ETA: </span><span id="eta"></span><span> seconds)</span>
        <br>
        <span>Current: </span><span id="current"></span>
        <div id="charts" class="">
            <canvas id="myChart" width="400" height="400"></canvas>
        </div>
    </body>
</html>
<script type="text/javascript">

var spotify_client_id = '04ec33bc2f0544b4b06c9c78c251ff07'; // Your client id (meh)
var spotify_client_secret = '595fe83b487d4924baef110f240d129b'; // Your secret (meh)
// var redirect_uri = 'http://localhost:8008/callback'; // Your redirect uri
var redirect_uri = (location.origin == "http://localhost:8008" ? location.origin+'/callback' : location.origin.location.pathname + "/callback")
var auth_url = `https://accounts.spotify.com/authorize/?client_id=${spotify_client_id}&response_type=code&redirect_uri=${encodeURIComponent(redirect_uri)}&scope=user-library-read`

var access_token = null
var refresh_token = null

var lastfm_api_key = "b25b959554ed76058ac220b7b2e0a026"

var songs = []
var requestedSongs = []
var lastFMProcessIndex = 0
var timer = null

var genreDemographics = {}

if (location.pathname === "/callback") {
    authenticate(spotify_client_id, spotify_client_secret, redirect_uri, populateSongs)
} else {
    location.replace(auth_url)
}

function recursiveGet(responseData, endpoint, request, requestsMade, limit, maxRequests=null, callback=()=>{}) {
    if (maxRequests !== null) {
        if (requestsMade > maxRequests) {
            callback()
            return
        }
    }
    if (!(responseData.items.length < limit)) {
        fetch(endpoint + `?limit=${limit}&offset=${requestsMade * limit}`, request)
        .then((blob) => blob.json())
        .then((data) => {
            songs.push(...data.items)
            createSongElements(data.items)
            recursiveGet(data, endpoint, request, requestsMade+1, limit, maxRequests, callback)
        })
    } else {
        callback()
    }
}

function populateSongs(access_token) {
    var endpoint = "https://api.spotify.com/v1/me/tracks"

    var headers = new Headers()
    headers.append('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8')
    headers.append('Authorization', "Bearer " + access_token)

    var request = { method: 'GET',
                   headers: headers,
                   mode: 'cors',
                   cache: 'default' }

    var requestsMade = 0
    var limit = 50

    fetch(endpoint + `?limit=${limit}&offset=${requestsMade * limit}`, request)
    .then((blob) => blob.json())
    .then((data) => {
        data.items.map(item => {
            songs.push({title: item.track.name, artist: item.track.artists[0].name})
        })
        getTagsForSongs()
        createSongElements(data.items)
        recursiveGet(data, endpoint, request, requestsMade+1, limit, 0)
    })
}

function getTagsForSongs() {
    console.warn("Getting tags");
    timer = setInterval(getSongTags, 200) // Last.fm limits requests to 5 per second per IP
}

function getSongTags() {

    if (lastFMProcessIndex < songs.length) {
        var title = songs[lastFMProcessIndex].title
        var artist = songs[lastFMProcessIndex].artist
// method=track.getInfo&api_key=b25b959554ed76058ac220b7b2e0a026&artist=cher&track=believe&format=json
        var endpoint = `http://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${lastfm_api_key}`
        var params = `&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(title)}`
        var appendix = "&user=RJ&format=json"
        // console.log(title, artist);
        fetch(endpoint + params + appendix)
        .then(blob => blob.json())
        .then(data => {
            tags =  data.track.toptags.tag
            tags.map(tag => {
                item = tag.name
                if (lastFMProcessIndex < songs.length) {
                    if (genreDemographics[item]) {
                        genreDemographics[item]["count"] += 1
                        genreDemographics[item]["tracks"].push(songs[lastFMProcessIndex])
                    } else {
                        genreDemographics[item] = {}
                        genreDemographics[item]["count"] = 1
                        genreDemographics[item]["tracks"] = [songs[lastFMProcessIndex]]
                    }
                }
            })
            requestedSongs.push({title: title, artist: artist, tags: tags})
            document.getElementById("totalLookedUp").innerHTML = lastFMProcessIndex
            document.getElementById("eta").innerHTML = 200 * (songs.length - lastFMProcessIndex) / 1000
            // var tags = ((tags.length === 0) ? "" : tags.reduce((acc, tag) => {
            //     return (acc + "" === "[object Object]" ? "" : acc) + tag.name + ","
            // }))
            document.getElementById("current").innerHTML = title + " - " + artist
        })
        lastFMProcessIndex += 1
    } else {
        console.log("clearing");
        window.clearInterval(timer)
        document.getElementById("fetchStatus").innerHTML = "Done fetching songs."
        analyzeSongs()
    }

}

function analyzeSongs() {
    console.log("Analyzing");
    // console.log(genreDemographics);
    var keysSorted = Object.keys(genreDemographics).sort(function(b,a){return genreDemographics[a].count-genreDemographics[b].count})
    var tabulated = []
    for (var i = 0; i < keysSorted.length; i++) {
        // console.log(genreDemographics[keysSorted[i]].tracks);
        tabulated.push([keysSorted[i], genreDemographics[keysSorted[i]].count, genreDemographics[keysSorted[i]].tracks])
    }
    console.table(tabulated)

    // Charts
    var labels = []
    var data = []
    for (var i = 0; i < 7; i++) {
        labels.push(tabulated[i][0])
        data.push(tabulated[i][1])
        console.log();
        console.log(tabulated[i][0], tabulated[i][1]);
    }
    console.log(labels);
    var ctx = document.getElementById("myChart");
    var myChart = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [{
                label: '# of songs',
                data: data,
                backgroundColor: [
                    'rgba(255, 99, 132, 0.2)',
                    'rgba(54, 162, 235, 0.2)',
                    'rgba(255, 206, 86, 0.2)',
                    'rgba(75, 192, 192, 0.2)',
                    'rgba(153, 102, 255, 0.2)',
                    'rgba(255, 159, 64, 0.2)'
                ],
                borderColor: [
                    'rgba(255,99,132,1)',
                    'rgba(54, 162, 235, 1)',
                    'rgba(255, 206, 86, 1)',
                    'rgba(75, 192, 192, 1)',
                    'rgba(153, 102, 255, 1)',
                    'rgba(255, 159, 64, 1)'
                ],
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                yAxes: [{
                    ticks: {
                        beginAtZero:true
                    }
                }]
            }
        }
    })
}

function createSongElements(tracks) {
    // var container = document.getElementById("songs")
    // var html = ""
    // tracks.map(track => {
    //     html += `<span>${track.track.name} - ${track.track.artists[0].name}</span><br>`
    // })
    // container.innerHTML += html
    document.getElementById("totalSongs").innerHTML = songs.length
}

function authenticate(spotify_client_id, spotify_client_secret, redirect_uri, callback) {
    var access_token = null
    var refresh_token = null

    function b64EncodeUnicode(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
            return String.fromCharCode('0x' + p1)
        }));
    }

    function httpGetAsync(theUrl, params, callback)
    {
        var xmlHttp = new XMLHttpRequest()
        xmlHttp.onreadystatechange = function() {
            if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
                callback(xmlHttp.responseText, xmlHttp.status)
            }
        }
        xmlHttp.open("POST", theUrl, true); // true for asynchronous
        xmlHttp.setRequestHeader("Authorization", "Basic " + b64EncodeUnicode(`${spotify_client_id}:${spotify_client_secret}`))
        xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=UTF-8")
        xmlHttp.send(params)
    }

    function gup(name, url) {
        if (!url) url = location.href;
        name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]")
        var regexS = "[\\?&]"+name+"=([^&#]*)"
        var regex = new RegExp( regexS )
        var results = regex.exec( url )
        return results == null ? null : results[1]
    }

    if (!(gup("error"))) {
        // console.log(gup("code"));
        httpGetAsync("https://accounts.spotify.com/api/token", `grant_type=authorization_code&code=${gup("code")}&redirect_uri=${encodeURIComponent(redirect_uri)}`, (responseText) => {
            var json = JSON.parse(responseText)
            access_token = json.access_token
            refresh_token = json.refresh_token
            callback(access_token, refresh_token)
        })
    } else {
        console.error("Error");
    }
}

</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.js" charset="utf-8"></script>
